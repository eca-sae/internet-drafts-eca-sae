Process 0 (that is, the initial process):
{1}new well_known_verifierIdKey: IdentityKey;
{2}let well_known_verifierPubKey: PublicKey = derivePubKey(well_known_verifierIdKey) in
(
    {3}!
    {4}new instanceFactor: InstanceFactor;
    {5}new ecaUuid: UUID;
    {6}let bf: BootFactor = bootFactor in
    {7}let ifa: InstanceFactor = instanceFactor in
    {8}let uuid: UUID = ecaUuid in
    {9}let authKey: bitstring = deriveAuthKey(bf,ifa,uuid) in
    {10}let encKey: EncPrivateKey = deriveEncKey(bf,ifa,uuid) in
    {11}let encPubKey: EncPublicKey = deriveEncPubKey(encKey) in
    {12}let ihb: IHB = calculateIHB(bf,ifa) in
    {13}event AttesterInitiates(bf,ifa,uuid);
    {14}let phase1_payload: bitstring = (encPubKey,ihb) in
    {15}let phase1_mac: MAC = computeMAC(phase1_payload,authKey) in
    {16}out(public_channel, (phase1_payload,phase1_mac));
    {17}in(public_channel, (ciphertext: bitstring,verifier_sig: Signature));
    {18}let verified_ciphertext: bitstring = verify(ciphertext,verifier_sig,well_known_verifierPubKey) in
    {19}let plaintext: bitstring = pdec(verified_ciphertext,encKey) in
    {20}let (vf: ValidatorFactor,nonce: Nonce) = plaintext in
    {21}event AttesterUsesNonce(nonce);
    {22}let idKey: IdentityKey = deriveIdKey(bf,vf,uuid) in
    {23}let pubKey: PublicKey = derivePubKey(idKey) in
    {24}event AttesterPresentsKey(pubKey);
    {25}let binding_proof: BindingProof = computeBindingProof(bf,vf,ihb,pubKey,nonce) in
    {26}let final_eat_payload: bitstring = (ihb,nonce,pubKey,binding_proof) in
    {27}let final_signature: Signature = sign(final_eat_payload,idKey) in
    {28}out(public_channel, (final_eat_payload,final_signature,pubKey))
) | (
    {29}!
    {30}new expected_ifa: InstanceFactor;
    {31}new expected_uuid: UUID;
    {32}let expected_bf: BootFactor = bootFactor in
    {33}let expected_ifa_1: InstanceFactor = expected_ifa in
    {34}let uuid_1: UUID = expected_uuid in
    {35}let verifierIdKey: IdentityKey = well_known_verifierIdKey in
    {36}in(public_channel, (phase1_payload_1: bitstring,phase1_mac_1: MAC));
    {37}let (attester_enc_pk: EncPublicKey,received_ihb: IHB) = phase1_payload_1 in
    {38}let expected_authKey: bitstring = deriveAuthKey(expected_bf,expected_ifa_1,uuid_1) in
    {39}if verifyMAC(phase1_payload_1,phase1_mac_1,expected_authKey) then
    {40}let expected_ihb: IHB = calculateIHB(expected_bf,expected_ifa_1) in
    {41}if (received_ihb = expected_ihb) then
    {42}let expected_encKey: EncPrivateKey = deriveEncKey(expected_bf,expected_ifa_1,uuid_1) in
    {43}let expected_encPubKey: EncPublicKey = deriveEncPubKey(expected_encKey) in
    {44}if (attester_enc_pk = expected_encPubKey) then
    {45}new seed: VFSeed;
    {46}let vf_1: ValidatorFactor = mkVF(seed,expected_ifa_1) in
    {47}event VFReleased(vf_1);
    {48}new nonce_1: Nonce;
    {49}event VerifierGeneratesNonce(nonce_1);
    {50}let plaintext_1: bitstring = (vf_1,nonce_1) in
    {51}let ciphertext_1: bitstring = penc(plaintext_1,attester_enc_pk) in
    {52}let verifier_signature: Signature = sign(ciphertext_1,verifierIdKey) in
    {53}event VerifierAuthenticated(verifierIdKey);
    {54}event VerifierKeyMatch(derivePubKey(verifierIdKey),verifierIdKey);
    {55}out(public_channel, (ciphertext_1,verifier_signature));
    {56}in(public_channel, (final_eat_payload_1: bitstring,final_signature_1: Signature,final_pubKey: PublicKey));
    {57}let verified_final: bitstring = verify(final_eat_payload_1,final_signature_1,final_pubKey) in
    {58}let (rec_ihb: IHB,rec_nonce: Nonce,rec_pubKey: PublicKey,rec_binding: BindingProof) = verified_final in
    {59}if (rec_nonce = nonce_1) then
    {60}let expected_idKey: IdentityKey = deriveIdKey(expected_bf,vf_1,uuid_1) in
    {61}let expected_pubKey: PublicKey = derivePubKey(expected_idKey) in
    {62}if (final_pubKey = expected_pubKey) then
    {63}if verifyBindingProof(rec_binding,expected_bf,vf_1,rec_ihb,rec_pubKey,rec_nonce) then
    {64}event VerifierValidatesBinding(expected_bf,vf_1,rec_ihb,rec_pubKey,rec_nonce);
    {65}event VerifierAccepts(expected_bf,expected_ifa_1,uuid_1)
) | (
    {66}new compromisedIF: InstanceFactor;
    {67}out(public_channel, compromisedIF)
) | (
    {68}!
    {69}new honestIF: InstanceFactor;
    {70}new testUuid: UUID;
    (
        {71}let bf_1: BootFactor = bootFactor in
        {72}let ifa_1: InstanceFactor = honestIF in
        {73}let uuid_2: UUID = testUuid in
        {74}let authKey_1: bitstring = deriveAuthKey(bf_1,ifa_1,uuid_2) in
        {75}let encKey_1: EncPrivateKey = deriveEncKey(bf_1,ifa_1,uuid_2) in
        {76}let encPubKey_1: EncPublicKey = deriveEncPubKey(encKey_1) in
        {77}let ihb_1: IHB = calculateIHB(bf_1,ifa_1) in
        {78}event AttesterInitiates(bf_1,ifa_1,uuid_2);
        {79}let phase1_payload_2: bitstring = (encPubKey_1,ihb_1) in
        {80}let phase1_mac_2: MAC = computeMAC(phase1_payload_2,authKey_1) in
        {81}out(public_channel, (phase1_payload_2,phase1_mac_2));
        {82}in(public_channel, (ciphertext_2: bitstring,verifier_sig_1: Signature));
        {83}let verified_ciphertext_1: bitstring = verify(ciphertext_2,verifier_sig_1,well_known_verifierPubKey) in
        {84}event AttesterAuthenticatesVerifier(well_known_verifierPubKey);
        {85}let plaintext_2: bitstring = pdec(verified_ciphertext_1,encKey_1) in
        {86}let (vf_2: ValidatorFactor,nonce_2: Nonce) = plaintext_2 in
        {87}event AttesterUsesNonce(nonce_2);
        {88}let idKey_1: IdentityKey = deriveIdKey(bf_1,vf_2,uuid_2) in
        {89}let pubKey_1: PublicKey = derivePubKey(idKey_1) in
        {90}event AttesterPresentsKey(pubKey_1);
        {91}let binding_proof_1: BindingProof = computeBindingProof(bf_1,vf_2,ihb_1,pubKey_1,nonce_2) in
        {92}let final_eat_payload_2: bitstring = (ihb_1,nonce_2,pubKey_1,binding_proof_1) in
        {93}let final_signature_2: Signature = sign(final_eat_payload_2,idKey_1) in
        {94}out(public_channel, (final_eat_payload_2,final_signature_2,pubKey_1))
    ) | (
        {95}let expected_bf_1: BootFactor = bootFactor in
        {96}let expected_ifa_2: InstanceFactor = honestIF in
        {97}let uuid_3: UUID = testUuid in
        {98}let verifierIdKey_1: IdentityKey = well_known_verifierIdKey in
        {99}in(public_channel, (phase1_payload_3: bitstring,phase1_mac_3: MAC));
        {100}let (attester_enc_pk_1: EncPublicKey,received_ihb_1: IHB) = phase1_payload_3 in
        {101}let expected_authKey_1: bitstring = deriveAuthKey(expected_bf_1,expected_ifa_2,uuid_3) in
        {102}if verifyMAC(phase1_payload_3,phase1_mac_3,expected_authKey_1) then
        {103}let expected_ihb_1: IHB = calculateIHB(expected_bf_1,expected_ifa_2) in
        {104}if (received_ihb_1 = expected_ihb_1) then
        {105}let expected_encKey_1: EncPrivateKey = deriveEncKey(expected_bf_1,expected_ifa_2,uuid_3) in
        {106}let expected_encPubKey_1: EncPublicKey = deriveEncPubKey(expected_encKey_1) in
        {107}if (attester_enc_pk_1 = expected_encPubKey_1) then
        {108}new seed_1: VFSeed;
        {109}let vf_3: ValidatorFactor = mkVF(seed_1,expected_ifa_2) in
        {110}event VFReleased(vf_3);
        {111}new nonce_3: Nonce;
        {112}event VerifierGeneratesNonce(nonce_3);
        {113}let plaintext_3: bitstring = (vf_3,nonce_3) in
        {114}let ciphertext_3: bitstring = penc(plaintext_3,attester_enc_pk_1) in
        {115}let verifier_signature_1: Signature = sign(ciphertext_3,verifierIdKey_1) in
        {116}event VerifierAuthenticated(verifierIdKey_1);
        {117}event VerifierKeyMatch(derivePubKey(verifierIdKey_1),verifierIdKey_1);
        {118}out(public_channel, (ciphertext_3,verifier_signature_1));
        {119}in(public_channel, (final_eat_payload_3: bitstring,final_signature_3: Signature,final_pubKey_1: PublicKey));
        {120}let verified_final_1: bitstring = verify(final_eat_payload_3,final_signature_3,final_pubKey_1) in
        {121}let (rec_ihb_1: IHB,rec_nonce_1: Nonce,rec_pubKey_1: PublicKey,rec_binding_1: BindingProof) = verified_final_1 in
        {122}if (rec_nonce_1 = nonce_3) then
        {123}let expected_idKey_1: IdentityKey = deriveIdKey(expected_bf_1,vf_3,uuid_3) in
        {124}let expected_pubKey_1: PublicKey = derivePubKey(expected_idKey_1) in
        {125}if (final_pubKey_1 = expected_pubKey_1) then
        {126}if verifyBindingProof(rec_binding_1,expected_bf_1,vf_3,rec_ihb_1,rec_pubKey_1,rec_nonce_1) then
        {127}event VerifierValidatesBinding(expected_bf_1,vf_3,rec_ihb_1,rec_pubKey_1,rec_nonce_1);
        {128}event VerifierAccepts(expected_bf_1,expected_ifa_2,uuid_3)
    )
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}new well_known_verifierIdKey: IdentityKey;
{2}let well_known_verifierPubKey: PublicKey = derivePubKey(well_known_verifierIdKey) in
(
    {3}!
    {4}new instanceFactor: InstanceFactor;
    {5}new ecaUuid: UUID;
    {8}let uuid: UUID = ecaUuid in
    {7}let ifa: InstanceFactor = instanceFactor in
    {6}let bf: BootFactor = bootFactor in
    {13}event AttesterInitiates(bf,ifa,uuid);
    {12}let ihb: IHB = calculateIHB(bf,ifa) in
    {10}let encKey: EncPrivateKey = deriveEncKey(bf,ifa,uuid) in
    {11}let encPubKey: EncPublicKey = deriveEncPubKey(encKey) in
    {14}let phase1_payload: bitstring = (encPubKey,ihb) in
    {9}let authKey: bitstring = deriveAuthKey(bf,ifa,uuid) in
    {15}let phase1_mac: MAC = computeMAC(phase1_payload,authKey) in
    {16}out(public_channel, (phase1_payload,phase1_mac));
    {17}in(public_channel, (ciphertext: bitstring,verifier_sig: Signature));
    {18}let verified_ciphertext: bitstring = verify(ciphertext,verifier_sig,well_known_verifierPubKey) in
    {19}let plaintext: bitstring = pdec(verified_ciphertext,encKey) in
    {20}let (vf: ValidatorFactor,nonce: Nonce) = plaintext in
    {21}event AttesterUsesNonce(nonce);
    {22}let idKey: IdentityKey = deriveIdKey(bf,vf,uuid) in
    {23}let pubKey: PublicKey = derivePubKey(idKey) in
    {24}event AttesterPresentsKey(pubKey);
    {25}let binding_proof: BindingProof = computeBindingProof(bf,vf,ihb,pubKey,nonce) in
    {26}let final_eat_payload: bitstring = (ihb,nonce,pubKey,binding_proof) in
    {27}let final_signature: Signature = sign(final_eat_payload,idKey) in
    {28}out(public_channel, (final_eat_payload,final_signature,pubKey))
) | (
    {29}!
    {30}new expected_ifa: InstanceFactor;
    {31}new expected_uuid: UUID;
    {36}in(public_channel, (phase1_payload_1: bitstring,phase1_mac_1: MAC));
    {37}let (attester_enc_pk: EncPublicKey,received_ihb: IHB) = phase1_payload_1 in
    {34}let uuid_1: UUID = expected_uuid in
    {33}let expected_ifa_1: InstanceFactor = expected_ifa in
    {32}let expected_bf: BootFactor = bootFactor in
    {38}let expected_authKey: bitstring = deriveAuthKey(expected_bf,expected_ifa_1,uuid_1) in
    {39}if verifyMAC(phase1_payload_1,phase1_mac_1,expected_authKey) then
    {40}let expected_ihb: IHB = calculateIHB(expected_bf,expected_ifa_1) in
    {41}if (received_ihb = expected_ihb) then
    {42}let expected_encKey: EncPrivateKey = deriveEncKey(expected_bf,expected_ifa_1,uuid_1) in
    {43}let expected_encPubKey: EncPublicKey = deriveEncPubKey(expected_encKey) in
    {44}if (attester_enc_pk = expected_encPubKey) then
    {45}new seed: VFSeed;
    {46}let vf_1: ValidatorFactor = mkVF(seed,expected_ifa_1) in
    {47}event VFReleased(vf_1);
    {48}new nonce_1: Nonce;
    {49}event VerifierGeneratesNonce(nonce_1);
    {35}let verifierIdKey: IdentityKey = well_known_verifierIdKey in
    {53}event VerifierAuthenticated(verifierIdKey);
    {54}event VerifierKeyMatch(derivePubKey(verifierIdKey),verifierIdKey);
    {50}let plaintext_1: bitstring = (vf_1,nonce_1) in
    {51}let ciphertext_1: bitstring = penc(plaintext_1,attester_enc_pk) in
    {52}let verifier_signature: Signature = sign(ciphertext_1,verifierIdKey) in
    {55}out(public_channel, (ciphertext_1,verifier_signature));
    {56}in(public_channel, (final_eat_payload_1: bitstring,final_signature_1: Signature,final_pubKey: PublicKey));
    {57}let verified_final: bitstring = verify(final_eat_payload_1,final_signature_1,final_pubKey) in
    {58}let (rec_ihb: IHB,rec_nonce: Nonce,rec_pubKey: PublicKey,rec_binding: BindingProof) = verified_final in
    {59}if (rec_nonce = nonce_1) then
    {60}let expected_idKey: IdentityKey = deriveIdKey(expected_bf,vf_1,uuid_1) in
    {61}let expected_pubKey: PublicKey = derivePubKey(expected_idKey) in
    {62}if (final_pubKey = expected_pubKey) then
    {63}if verifyBindingProof(rec_binding,expected_bf,vf_1,rec_ihb,rec_pubKey,rec_nonce) then
    {64}event VerifierValidatesBinding(expected_bf,vf_1,rec_ihb,rec_pubKey,rec_nonce);
    {65}event VerifierAccepts(expected_bf,expected_ifa_1,uuid_1)
) | (
    {66}new compromisedIF: InstanceFactor;
    {67}out(public_channel, compromisedIF)
) | (
    {68}!
    {69}new honestIF: InstanceFactor;
    {70}new testUuid: UUID;
    (
        {73}let uuid_2: UUID = testUuid in
        {72}let ifa_1: InstanceFactor = honestIF in
        {71}let bf_1: BootFactor = bootFactor in
        {78}event AttesterInitiates(bf_1,ifa_1,uuid_2);
        {77}let ihb_1: IHB = calculateIHB(bf_1,ifa_1) in
        {75}let encKey_1: EncPrivateKey = deriveEncKey(bf_1,ifa_1,uuid_2) in
        {76}let encPubKey_1: EncPublicKey = deriveEncPubKey(encKey_1) in
        {79}let phase1_payload_2: bitstring = (encPubKey_1,ihb_1) in
        {74}let authKey_1: bitstring = deriveAuthKey(bf_1,ifa_1,uuid_2) in
        {80}let phase1_mac_2: MAC = computeMAC(phase1_payload_2,authKey_1) in
        {81}out(public_channel, (phase1_payload_2,phase1_mac_2));
        {82}in(public_channel, (ciphertext_2: bitstring,verifier_sig_1: Signature));
        {83}let verified_ciphertext_1: bitstring = verify(ciphertext_2,verifier_sig_1,well_known_verifierPubKey) in
        {84}event AttesterAuthenticatesVerifier(well_known_verifierPubKey);
        {85}let plaintext_2: bitstring = pdec(verified_ciphertext_1,encKey_1) in
        {86}let (vf_2: ValidatorFactor,nonce_2: Nonce) = plaintext_2 in
        {87}event AttesterUsesNonce(nonce_2);
        {88}let idKey_1: IdentityKey = deriveIdKey(bf_1,vf_2,uuid_2) in
        {89}let pubKey_1: PublicKey = derivePubKey(idKey_1) in
        {90}event AttesterPresentsKey(pubKey_1);
        {91}let binding_proof_1: BindingProof = computeBindingProof(bf_1,vf_2,ihb_1,pubKey_1,nonce_2) in
        {92}let final_eat_payload_2: bitstring = (ihb_1,nonce_2,pubKey_1,binding_proof_1) in
        {93}let final_signature_2: Signature = sign(final_eat_payload_2,idKey_1) in
        {94}out(public_channel, (final_eat_payload_2,final_signature_2,pubKey_1))
    ) | (
        {99}in(public_channel, (phase1_payload_3: bitstring,phase1_mac_3: MAC));
        {100}let (attester_enc_pk_1: EncPublicKey,received_ihb_1: IHB) = phase1_payload_3 in
        {97}let uuid_3: UUID = testUuid in
        {96}let expected_ifa_2: InstanceFactor = honestIF in
        {95}let expected_bf_1: BootFactor = bootFactor in
        {101}let expected_authKey_1: bitstring = deriveAuthKey(expected_bf_1,expected_ifa_2,uuid_3) in
        {102}if verifyMAC(phase1_payload_3,phase1_mac_3,expected_authKey_1) then
        {103}let expected_ihb_1: IHB = calculateIHB(expected_bf_1,expected_ifa_2) in
        {104}if (received_ihb_1 = expected_ihb_1) then
        {105}let expected_encKey_1: EncPrivateKey = deriveEncKey(expected_bf_1,expected_ifa_2,uuid_3) in
        {106}let expected_encPubKey_1: EncPublicKey = deriveEncPubKey(expected_encKey_1) in
        {107}if (attester_enc_pk_1 = expected_encPubKey_1) then
        {108}new seed_1: VFSeed;
        {109}let vf_3: ValidatorFactor = mkVF(seed_1,expected_ifa_2) in
        {110}event VFReleased(vf_3);
        {111}new nonce_3: Nonce;
        {112}event VerifierGeneratesNonce(nonce_3);
        {98}let verifierIdKey_1: IdentityKey = well_known_verifierIdKey in
        {116}event VerifierAuthenticated(verifierIdKey_1);
        {117}event VerifierKeyMatch(derivePubKey(verifierIdKey_1),verifierIdKey_1);
        {113}let plaintext_3: bitstring = (vf_3,nonce_3) in
        {114}let ciphertext_3: bitstring = penc(plaintext_3,attester_enc_pk_1) in
        {115}let verifier_signature_1: Signature = sign(ciphertext_3,verifierIdKey_1) in
        {118}out(public_channel, (ciphertext_3,verifier_signature_1));
        {119}in(public_channel, (final_eat_payload_3: bitstring,final_signature_3: Signature,final_pubKey_1: PublicKey));
        {120}let verified_final_1: bitstring = verify(final_eat_payload_3,final_signature_3,final_pubKey_1) in
        {121}let (rec_ihb_1: IHB,rec_nonce_1: Nonce,rec_pubKey_1: PublicKey,rec_binding_1: BindingProof) = verified_final_1 in
        {122}if (rec_nonce_1 = nonce_3) then
        {123}let expected_idKey_1: IdentityKey = deriveIdKey(expected_bf_1,vf_3,uuid_3) in
        {124}let expected_pubKey_1: PublicKey = derivePubKey(expected_idKey_1) in
        {125}if (final_pubKey_1 = expected_pubKey_1) then
        {126}if verifyBindingProof(rec_binding_1,expected_bf_1,vf_3,rec_ihb_1,rec_pubKey_1,rec_nonce_1) then
        {127}event VerifierValidatesBinding(expected_bf_1,vf_3,rec_ihb_1,rec_pubKey_1,rec_nonce_1);
        {128}event VerifierAccepts(expected_bf_1,expected_ifa_2,uuid_3)
    )
)

-- Query not attacker(bootFactor[]) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not attacker(bootFactor[])
goal reachable: attacker(bootFactor[])

Derivation:

1. The attacker initially knows bootFactor[].
attacker(bootFactor[]).

2. By 1, attacker(bootFactor[]).
The goal is reached, represented in the following fact:
attacker(bootFactor[]).


A more detailed output of the traces is available with
  set traceDisplay = long.

new well_known_verifierIdKey: IdentityKey creating well_known_verifierIdKey_1 at {1}

new compromisedIF: InstanceFactor creating compromisedIF_1 at {66}

out(public_channel, ~M) with ~M = compromisedIF_1 at {67}

The attacker has the message bootFactor.
A trace has been found.
RESULT not attacker(bootFactor[]) is false.
-- Query not attacker(deriveIdKey(bf_2,vf_4,uuid_4)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not attacker(deriveIdKey(bf_2,vf_4,uuid_4))
goal reachable: attacker(bf_2) && attacker(vf_4) && attacker(uuid_4) -> attacker(deriveIdKey(bf_2,vf_4,uuid_4))

Derivation:

1. We assume as hypothesis that
attacker(uuid_4).

2. We assume as hypothesis that
attacker(vf_4).

3. We assume as hypothesis that
attacker(bf_2).

4. By 3, the attacker may know bf_2.
By 2, the attacker may know vf_4.
By 1, the attacker may know uuid_4.
Using the function deriveIdKey the attacker may obtain deriveIdKey(bf_2,vf_4,uuid_4).
attacker(deriveIdKey(bf_2,vf_4,uuid_4)).

5. By 4, attacker(deriveIdKey(bf_2,vf_4,uuid_4)).
The goal is reached, represented in the following fact:
attacker(deriveIdKey(bf_2,vf_4,uuid_4)).


A more detailed output of the traces is available with
  set traceDisplay = long.

new well_known_verifierIdKey: IdentityKey creating well_known_verifierIdKey_1 at {1}

new compromisedIF: InstanceFactor creating compromisedIF_1 at {66}

out(public_channel, ~M) with ~M = compromisedIF_1 at {67}

The attacker has the message deriveIdKey(a,a_1,a_2).
A trace has been found.
RESULT not attacker(deriveIdKey(bf_2,vf_4,uuid_4)) is false.
-- Query inj-event(VerifierAccepts(bf_2,ifa_2,uuid_4)) ==> inj-event(AttesterInitiates(bf_2,ifa_2,uuid_4)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query inj-event(VerifierAccepts(bf_2,ifa_2,uuid_4)) ==> inj-event(AttesterInitiates(bf_2,ifa_2,uuid_4))
goal reachable: b-event(@p_act(@occ82_1,(penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))),sign(penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))),well_known_verifierIdKey[])))) && b-inj-event(AttesterInitiates(bootFactor[],honestIF_1,testUuid_1),@occ78_1) -> inj-event(VerifierAccepts(bootFactor[],honestIF_1,testUuid_1),@occ128_1)
The 1st, 2nd hypotheses occur strictly before the conclusion.
Abbreviations:
honestIF_1 = honestIF[!1 = @sid]
testUuid_1 = testUuid[!1 = @sid]
seed_2 = seed_1[phase1_mac_3 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),deriveAuthKey(bootFactor[],honestIF_1,testUuid_1)),phase1_payload_3 = (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),!1 = @sid]
nonce_4 = nonce_3[phase1_mac_3 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),deriveAuthKey(bootFactor[],honestIF_1,testUuid_1)),phase1_payload_3 = (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),!1 = @sid]
@occ128_1 = @occ128[final_pubKey_1 = derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,honestIF_1),testUuid_1)),final_signature_3 = sign((calculateIHB(bootFactor[],honestIF_1),nonce_4,derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,honestIF_1),testUuid_1)),computeBindingProof(bootFactor[],mkVF(seed_2,honestIF_1),calculateIHB(bootFactor[],honestIF_1),derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,honestIF_1),testUuid_1)),nonce_4)),deriveIdKey(bootFactor[],mkVF(seed_2,honestIF_1),testUuid_1)),final_eat_payload_3 = (calculateIHB(bootFactor[],honestIF_1),nonce_4,derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,honestIF_1),testUuid_1)),computeBindingProof(bootFactor[],mkVF(seed_2,honestIF_1),calculateIHB(bootFactor[],honestIF_1),derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,honestIF_1),testUuid_1)),nonce_4)),phase1_mac_3 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),deriveAuthKey(bootFactor[],honestIF_1,testUuid_1)),phase1_payload_3 = (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),!1 = @sid]
@occ82_1 = @occ82[!1 = @sid]
@occ78_1 = @occ78[!1 = @sid]
RESULT inj-event(VerifierAccepts(bf_2,ifa_2,uuid_4)) ==> inj-event(AttesterInitiates(bf_2,ifa_2,uuid_4)) is true.
-- Query event(AttesterUsesNonce(n)) ==> event(VerifierGeneratesNonce(n)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query event(AttesterUsesNonce(n)) ==> event(VerifierGeneratesNonce(n))
goal reachable: b-event(VerifierGeneratesNonce(nonce_4)) -> event(AttesterUsesNonce(nonce_4))
Abbreviations:
honestIF_1 = honestIF[!1 = @sid]
testUuid_1 = testUuid[!1 = @sid]
nonce_4 = nonce_3[phase1_mac_3 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),deriveAuthKey(bootFactor[],honestIF_1,testUuid_1)),phase1_payload_3 = (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),!1 = @sid]
RESULT event(AttesterUsesNonce(n)) ==> event(VerifierGeneratesNonce(n)) is true.
-- Query event(VerifierValidatesBinding(bf_2,vf_4,ihb_2,pk,n)) ==> event(AttesterPresentsKey(pk)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query event(VerifierValidatesBinding(bf_2,vf_4,ihb_2,pk,n)) ==> event(AttesterPresentsKey(pk))
goal reachable: b-event(AttesterPresentsKey(derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,honestIF_1),testUuid_1)))) -> event(VerifierValidatesBinding(bootFactor[],mkVF(seed_2,honestIF_1),calculateIHB(bootFactor[],honestIF_1),derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_2,honestIF_1),testUuid_1)),nonce_4))
Abbreviations:
honestIF_1 = honestIF[!1 = @sid]
testUuid_1 = testUuid[!1 = @sid]
seed_2 = seed_1[phase1_mac_3 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),deriveAuthKey(bootFactor[],honestIF_1,testUuid_1)),phase1_payload_3 = (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),!1 = @sid]
nonce_4 = nonce_3[phase1_mac_3 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),deriveAuthKey(bootFactor[],honestIF_1,testUuid_1)),phase1_payload_3 = (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),!1 = @sid]
RESULT event(VerifierValidatesBinding(bf_2,vf_4,ihb_2,pk,n)) ==> event(AttesterPresentsKey(pk)) is true.
-- Query not (event(VFReleased(vf_4)) && attacker(vf_4)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not (event(VFReleased(vf_4)) && attacker(vf_4))
RESULT not (event(VFReleased(vf_4)) && attacker(vf_4)) is true.
-- Query not (event(AttesterAuthenticatesVerifier(pk)) && event(VerifierKeyMatch(pk,vk))) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not (event(AttesterAuthenticatesVerifier(pk)) && event(VerifierKeyMatch(pk,vk)))
goal reachable: event(AttesterAuthenticatesVerifier(derivePubKey(well_known_verifierIdKey[]))) && event(VerifierKeyMatch(derivePubKey(well_known_verifierIdKey[]),well_known_verifierIdKey[]))

Derivation:
Abbreviations:
honestIF_1 = honestIF[!1 = @sid]
testUuid_1 = testUuid[!1 = @sid]
seed_2 = seed_1[phase1_mac_3 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),deriveAuthKey(bootFactor[],honestIF_1,testUuid_1)),phase1_payload_3 = (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),!1 = @sid]
nonce_4 = nonce_3[phase1_mac_3 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),deriveAuthKey(bootFactor[],honestIF_1,testUuid_1)),phase1_payload_3 = (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),!1 = @sid]
honestIF_2 = honestIF[!1 = @sid_1]
testUuid_2 = testUuid[!1 = @sid_1]

1. The message ((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)),deriveAuthKey(bootFactor[],honestIF_2,testUuid_2))) may be sent to the attacker at output {81}.
attacker(((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)),deriveAuthKey(bootFactor[],honestIF_2,testUuid_2)))).

2. By 1, the attacker may know ((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)),deriveAuthKey(bootFactor[],honestIF_2,testUuid_2))).
Using the function 2-proj-2-tuple the attacker may obtain computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)),deriveAuthKey(bootFactor[],honestIF_2,testUuid_2)).
attacker(computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)),deriveAuthKey(bootFactor[],honestIF_2,testUuid_2))).

3. By 1, the attacker may know ((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)),deriveAuthKey(bootFactor[],honestIF_2,testUuid_2))).
Using the function 1-proj-2-tuple the attacker may obtain (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)).
attacker((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2))).

4. By 3, the attacker may know (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)).
Using the function 2-proj-2-tuple the attacker may obtain calculateIHB(bootFactor[],honestIF_2).
attacker(calculateIHB(bootFactor[],honestIF_2)).

5. By 3, the attacker may know (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)).
Using the function 1-proj-2-tuple the attacker may obtain deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)).
attacker(deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2))).

6. By 5, the attacker may know deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)).
By 4, the attacker may know calculateIHB(bootFactor[],honestIF_2).
Using the function 2-tuple the attacker may obtain (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)).
attacker((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2))).

7. By 6, the attacker may know (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)).
By 2, the attacker may know computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)),deriveAuthKey(bootFactor[],honestIF_2,testUuid_2)).
Using the function 2-tuple the attacker may obtain ((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)),deriveAuthKey(bootFactor[],honestIF_2,testUuid_2))).
attacker(((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)),deriveAuthKey(bootFactor[],honestIF_2,testUuid_2)))).

8. The message ((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_2,testUuid_2)),calculateIHB(bootFactor[],honestIF_2)),deriveAuthKey(bootFactor[],honestIF_2,testUuid_2))) that the attacker may have by 7 may be received at input {99}.
So event VerifierKeyMatch(derivePubKey(well_known_verifierIdKey[]),well_known_verifierIdKey[]) may be executed at {117}.
event(VerifierKeyMatch(derivePubKey(well_known_verifierIdKey[]),well_known_verifierIdKey[])).

9. The message ((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),deriveAuthKey(bootFactor[],honestIF_1,testUuid_1))) may be sent to the attacker at output {81}.
attacker(((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),deriveAuthKey(bootFactor[],honestIF_1,testUuid_1)))).

10. By 9, the attacker may know ((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),deriveAuthKey(bootFactor[],honestIF_1,testUuid_1))).
Using the function 2-proj-2-tuple the attacker may obtain computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),deriveAuthKey(bootFactor[],honestIF_1,testUuid_1)).
attacker(computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),deriveAuthKey(bootFactor[],honestIF_1,testUuid_1))).

11. By 9, the attacker may know ((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),deriveAuthKey(bootFactor[],honestIF_1,testUuid_1))).
Using the function 1-proj-2-tuple the attacker may obtain (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)).
attacker((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1))).

12. By 11, the attacker may know (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)).
Using the function 2-proj-2-tuple the attacker may obtain calculateIHB(bootFactor[],honestIF_1).
attacker(calculateIHB(bootFactor[],honestIF_1)).

13. By 11, the attacker may know (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)).
Using the function 1-proj-2-tuple the attacker may obtain deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)).
attacker(deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))).

14. By 13, the attacker may know deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)).
By 12, the attacker may know calculateIHB(bootFactor[],honestIF_1).
Using the function 2-tuple the attacker may obtain (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)).
attacker((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1))).

15. By 14, the attacker may know (deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)).
By 10, the attacker may know computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),deriveAuthKey(bootFactor[],honestIF_1,testUuid_1)).
Using the function 2-tuple the attacker may obtain ((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),deriveAuthKey(bootFactor[],honestIF_1,testUuid_1))).
attacker(((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),deriveAuthKey(bootFactor[],honestIF_1,testUuid_1)))).

16. The message ((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)),calculateIHB(bootFactor[],honestIF_1)),deriveAuthKey(bootFactor[],honestIF_1,testUuid_1))) that the attacker may have by 15 may be received at input {99}.
So the message (penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))),sign(penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))),well_known_verifierIdKey[])) may be sent to the attacker at output {118}.
attacker((penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))),sign(penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))),well_known_verifierIdKey[]))).

17. By 16, the attacker may know (penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))),sign(penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))),well_known_verifierIdKey[])).
Using the function 2-proj-2-tuple the attacker may obtain sign(penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))),well_known_verifierIdKey[]).
attacker(sign(penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))),well_known_verifierIdKey[])).

18. By 16, the attacker may know (penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))),sign(penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))),well_known_verifierIdKey[])).
Using the function 1-proj-2-tuple the attacker may obtain penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))).
attacker(penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1)))).

19. By 18, the attacker may know penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))).
By 17, the attacker may know sign(penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))),well_known_verifierIdKey[]).
Using the function 2-tuple the attacker may obtain (penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))),sign(penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))),well_known_verifierIdKey[])).
attacker((penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))),sign(penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))),well_known_verifierIdKey[]))).

20. The message (penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))),sign(penc((mkVF(seed_2,honestIF_1),nonce_4),deriveEncPubKey(deriveEncKey(bootFactor[],honestIF_1,testUuid_1))),well_known_verifierIdKey[])) that the attacker may have by 19 may be received at input {82}.
So event AttesterAuthenticatesVerifier(derivePubKey(well_known_verifierIdKey[])) may be executed at {84}.
event(AttesterAuthenticatesVerifier(derivePubKey(well_known_verifierIdKey[]))).

21. By 20, event(AttesterAuthenticatesVerifier(derivePubKey(well_known_verifierIdKey[]))).
By 8, event(VerifierKeyMatch(derivePubKey(well_known_verifierIdKey[]),well_known_verifierIdKey[])).
The goals are reached, combined in the following fact:
event(AttesterAuthenticatesVerifier(derivePubKey(well_known_verifierIdKey[]))) && event(VerifierKeyMatch(derivePubKey(well_known_verifierIdKey[]),well_known_verifierIdKey[])).


A more detailed output of the traces is available with
  set traceDisplay = long.

new well_known_verifierIdKey: IdentityKey creating well_known_verifierIdKey_1 at {1}

new honestIF: InstanceFactor creating honestIF_3 at {69} in copy a

new testUuid: UUID creating testUuid_3 at {70} in copy a

event AttesterInitiates(bootFactor,honestIF_3,testUuid_3) at {78} in copy a

out(public_channel, ((~M,~M_1),~M_2)) with ~M = deriveEncPubKey(deriveEncKey(bootFactor,honestIF_3,testUuid_3)), ~M_1 = calculateIHB(bootFactor,honestIF_3), ~M_2 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor,honestIF_3,testUuid_3)),calculateIHB(bootFactor,honestIF_3)),deriveAuthKey(bootFactor,honestIF_3,testUuid_3)) at {81} in copy a

new honestIF: InstanceFactor creating honestIF_4 at {69} in copy a_1

new testUuid: UUID creating testUuid_4 at {70} in copy a_1

event AttesterInitiates(bootFactor,honestIF_4,testUuid_4) at {78} in copy a_1

out(public_channel, ((~M_3,~M_4),~M_5)) with ~M_3 = deriveEncPubKey(deriveEncKey(bootFactor,honestIF_4,testUuid_4)), ~M_4 = calculateIHB(bootFactor,honestIF_4), ~M_5 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor,honestIF_4,testUuid_4)),calculateIHB(bootFactor,honestIF_4)),deriveAuthKey(bootFactor,honestIF_4,testUuid_4)) at {81} in copy a_1

new honestIF: InstanceFactor creating honestIF_5 at {69} in copy a_2

new testUuid: UUID creating testUuid_5 at {70} in copy a_2

event AttesterInitiates(bootFactor,honestIF_5,testUuid_5) at {78} in copy a_2

out(public_channel, ((~M_6,~M_7),~M_8)) with ~M_6 = deriveEncPubKey(deriveEncKey(bootFactor,honestIF_5,testUuid_5)), ~M_7 = calculateIHB(bootFactor,honestIF_5), ~M_8 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor,honestIF_5,testUuid_5)),calculateIHB(bootFactor,honestIF_5)),deriveAuthKey(bootFactor,honestIF_5,testUuid_5)) at {81} in copy a_2

new compromisedIF: InstanceFactor creating compromisedIF_1 at {66}

out(public_channel, ~M_9) with ~M_9 = compromisedIF_1 at {67}

in(public_channel, ((~M_6,~M_7),~M_8)) with ~M_6 = deriveEncPubKey(deriveEncKey(bootFactor,honestIF_5,testUuid_5)), ~M_7 = calculateIHB(bootFactor,honestIF_5), ~M_8 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor,honestIF_5,testUuid_5)),calculateIHB(bootFactor,honestIF_5)),deriveAuthKey(bootFactor,honestIF_5,testUuid_5)) at {99} in copy a_2

new seed_1: VFSeed creating seed_3 at {108} in copy a_2

event VFReleased(mkVF(seed_3,honestIF_5)) at {110} in copy a_2

new nonce_3: Nonce creating nonce_5 at {111} in copy a_2

event VerifierGeneratesNonce(nonce_5) at {112} in copy a_2

event VerifierAuthenticated(well_known_verifierIdKey_1) at {116} in copy a_2

event VerifierKeyMatch(derivePubKey(well_known_verifierIdKey_1),well_known_verifierIdKey_1) at {117} in copy a_2 (goal)

out(public_channel, (~M_10,~M_11)) with ~M_10 = penc((mkVF(seed_3,honestIF_5),nonce_5),deriveEncPubKey(deriveEncKey(bootFactor,honestIF_5,testUuid_5))), ~M_11 = sign(penc((mkVF(seed_3,honestIF_5),nonce_5),deriveEncPubKey(deriveEncKey(bootFactor,honestIF_5,testUuid_5))),well_known_verifierIdKey_1) at {118} in copy a_2

in(public_channel, (~M_10,~M_11)) with ~M_10 = penc((mkVF(seed_3,honestIF_5),nonce_5),deriveEncPubKey(deriveEncKey(bootFactor,honestIF_5,testUuid_5))), ~M_11 = sign(penc((mkVF(seed_3,honestIF_5),nonce_5),deriveEncPubKey(deriveEncKey(bootFactor,honestIF_5,testUuid_5))),well_known_verifierIdKey_1) at {82} in copy a_1

event AttesterAuthenticatesVerifier(derivePubKey(well_known_verifierIdKey_1)) at {84} in copy a_1 (goal)

The event AttesterAuthenticatesVerifier(derivePubKey(well_known_verifierIdKey_1)) is executed at {84} in copy a_1.
The event VerifierKeyMatch(derivePubKey(well_known_verifierIdKey_1),well_known_verifierIdKey_1) is executed at {117} in copy a_2.
A trace has been found.
RESULT not (event(AttesterAuthenticatesVerifier(pk)) && event(VerifierKeyMatch(pk,vk))) is false.

--------------------------------------------------------------
Verification summary:

Query not attacker(bootFactor[]) is false.

Query not attacker(deriveIdKey(bf_2,vf_4,uuid_4)) is false.

Query inj-event(VerifierAccepts(bf_2,ifa_2,uuid_4)) ==> inj-event(AttesterInitiates(bf_2,ifa_2,uuid_4)) is true.

Query event(AttesterUsesNonce(n)) ==> event(VerifierGeneratesNonce(n)) is true.

Query event(VerifierValidatesBinding(bf_2,vf_4,ihb_2,pk,n)) ==> event(AttesterPresentsKey(pk)) is true.

Query not (event(VFReleased(vf_4)) && attacker(vf_4)) is true.

Query not (event(AttesterAuthenticatesVerifier(pk)) && event(VerifierKeyMatch(pk,vk))) is false.

--------------------------------------------------------------

