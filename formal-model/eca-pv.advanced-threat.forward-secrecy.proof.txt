Process 0 (that is, the initial process):
{1}new instanceFactor: InstanceFactor;
{2}new ecaUuid: UUID;
{3}new verifierIdKey: IdentityKey;
{4}let verifierPubKey: PublicKey = derivePubKey(verifierIdKey) in
(
    {5}let bf: BootFactor = bootFactor in
    {6}let ifa: InstanceFactor = instanceFactor in
    {7}let uuid: UUID = ecaUuid in
    {8}let authKey: bitstring = deriveAuthKey(bf,ifa,uuid) in
    {9}let encKey: EncPrivateKey = deriveEncKey(bf,ifa,uuid) in
    {10}let encPubKey: EncPublicKey = deriveEncPubKey(encKey) in
    {11}let ihb: IHB = calculateIHB(bf,ifa) in
    {12}event AttesterInitiates(bf,ifa,uuid);
    {13}let phase1_payload: bitstring = (encPubKey,ihb) in
    {14}let phase1_mac: MAC = computeMAC(phase1_payload,authKey) in
    {15}out(public_channel, (phase1_payload,phase1_mac));
    {16}in(public_channel, (ciphertext: bitstring,verifier_sig: Signature));
    {17}let verified_ciphertext: bitstring = verify(ciphertext,verifier_sig,verifierPubKey) in
    {18}let plaintext: bitstring = pdec(verified_ciphertext,encKey) in
    {19}let (vf: ValidatorFactor,nonce: Nonce) = plaintext in
    {20}event AttesterUsesNonce(nonce);
    {21}let idKey: IdentityKey = deriveIdKey(bf,vf,uuid) in
    {22}let pubKey: PublicKey = derivePubKey(idKey) in
    {23}event AttesterPresentsKey(pubKey);
    {24}let binding_proof: BindingProof = computeBindingProof(bf,vf,ihb,pubKey,nonce) in
    {25}let final_eat_payload: bitstring = (ihb,nonce,pubKey,binding_proof) in
    {26}let final_signature: Signature = sign(final_eat_payload,idKey) in
    {27}out(public_channel, (final_eat_payload,final_signature,pubKey));
    {28}event ProtocolCompleted(uuid)
) | (
    {29}let expected_bf: BootFactor = bootFactor in
    {30}let expected_ifa: InstanceFactor = instanceFactor in
    {31}let uuid_1: UUID = ecaUuid in
    {32}let verifierIdKey_1: IdentityKey = verifierIdKey in
    {33}in(public_channel, (phase1_payload_1: bitstring,phase1_mac_1: MAC));
    {34}let (attester_enc_pk: EncPublicKey,received_ihb: IHB) = phase1_payload_1 in
    {35}let expected_authKey: bitstring = deriveAuthKey(expected_bf,expected_ifa,uuid_1) in
    {36}if verifyMAC(phase1_payload_1,phase1_mac_1,expected_authKey) then
    {37}let expected_ihb: IHB = calculateIHB(expected_bf,expected_ifa) in
    {38}if (received_ihb = expected_ihb) then
    {39}let expected_encKey: EncPrivateKey = deriveEncKey(expected_bf,expected_ifa,uuid_1) in
    {40}let expected_encPubKey: EncPublicKey = deriveEncPubKey(expected_encKey) in
    {41}if (attester_enc_pk = expected_encPubKey) then
    {42}new seed: VFSeed;
    {43}let vf_1: ValidatorFactor = mkVF(seed,expected_ifa) in
    {44}event VFReleased(vf_1);
    {45}new nonce_1: Nonce;
    {46}event VerifierGeneratesNonce(nonce_1);
    {47}let plaintext_1: bitstring = (vf_1,nonce_1) in
    {48}let ciphertext_1: bitstring = penc(plaintext_1,attester_enc_pk) in
    {49}let verifier_signature: Signature = sign(ciphertext_1,verifierIdKey_1) in
    {50}out(public_channel, (ciphertext_1,verifier_signature));
    {51}in(public_channel, (final_eat_payload_1: bitstring,final_signature_1: Signature,final_pubKey: PublicKey));
    {52}let verified_final: bitstring = verify(final_eat_payload_1,final_signature_1,final_pubKey) in
    {53}let (rec_ihb: IHB,rec_nonce: Nonce,rec_pubKey: PublicKey,rec_binding: BindingProof) = verified_final in
    {54}if (rec_nonce = nonce_1) then
    {55}let expected_idKey: IdentityKey = deriveIdKey(expected_bf,vf_1,uuid_1) in
    {56}let expected_pubKey: PublicKey = derivePubKey(expected_idKey) in
    {57}if (final_pubKey = expected_pubKey) then
    {58}if verifyBindingProof(rec_binding,expected_bf,vf_1,rec_ihb,rec_pubKey,rec_nonce) then
    {59}event VerifierValidatesBinding(expected_bf,vf_1,rec_ihb,rec_pubKey,rec_nonce);
    {60}event VerifierAccepts(expected_bf,expected_ifa,uuid_1);
    {61}event ProtocolCompleted(uuid_1)
) | (
    {62}let verifierIdKey_2: IdentityKey = verifierIdKey in
    {63}event VerifierKeyCompromised(verifierIdKey_2);
    {64}out(public_channel, verifierIdKey_2)
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}new instanceFactor: InstanceFactor;
{2}new ecaUuid: UUID;
{3}new verifierIdKey: IdentityKey;
(
    {7}let uuid: UUID = ecaUuid in
    {6}let ifa: InstanceFactor = instanceFactor in
    {5}let bf: BootFactor = bootFactor in
    {12}event AttesterInitiates(bf,ifa,uuid);
    {11}let ihb: IHB = calculateIHB(bf,ifa) in
    {9}let encKey: EncPrivateKey = deriveEncKey(bf,ifa,uuid) in
    {10}let encPubKey: EncPublicKey = deriveEncPubKey(encKey) in
    {13}let phase1_payload: bitstring = (encPubKey,ihb) in
    {8}let authKey: bitstring = deriveAuthKey(bf,ifa,uuid) in
    {14}let phase1_mac: MAC = computeMAC(phase1_payload,authKey) in
    {15}out(public_channel, (phase1_payload,phase1_mac));
    {16}in(public_channel, (ciphertext: bitstring,verifier_sig: Signature));
    {4}let verifierPubKey: PublicKey = derivePubKey(verifierIdKey) in
    {17}let verified_ciphertext: bitstring = verify(ciphertext,verifier_sig,verifierPubKey) in
    {18}let plaintext: bitstring = pdec(verified_ciphertext,encKey) in
    {19}let (vf: ValidatorFactor,nonce: Nonce) = plaintext in
    {20}event AttesterUsesNonce(nonce);
    {21}let idKey: IdentityKey = deriveIdKey(bf,vf,uuid) in
    {22}let pubKey: PublicKey = derivePubKey(idKey) in
    {23}event AttesterPresentsKey(pubKey);
    {24}let binding_proof: BindingProof = computeBindingProof(bf,vf,ihb,pubKey,nonce) in
    {25}let final_eat_payload: bitstring = (ihb,nonce,pubKey,binding_proof) in
    {26}let final_signature: Signature = sign(final_eat_payload,idKey) in
    {27}out(public_channel, (final_eat_payload,final_signature,pubKey));
    {28}event ProtocolCompleted(uuid)
) | (
    {33}in(public_channel, (phase1_payload_1: bitstring,phase1_mac_1: MAC));
    {34}let (attester_enc_pk: EncPublicKey,received_ihb: IHB) = phase1_payload_1 in
    {31}let uuid_1: UUID = ecaUuid in
    {30}let expected_ifa: InstanceFactor = instanceFactor in
    {29}let expected_bf: BootFactor = bootFactor in
    {35}let expected_authKey: bitstring = deriveAuthKey(expected_bf,expected_ifa,uuid_1) in
    {36}if verifyMAC(phase1_payload_1,phase1_mac_1,expected_authKey) then
    {37}let expected_ihb: IHB = calculateIHB(expected_bf,expected_ifa) in
    {38}if (received_ihb = expected_ihb) then
    {39}let expected_encKey: EncPrivateKey = deriveEncKey(expected_bf,expected_ifa,uuid_1) in
    {40}let expected_encPubKey: EncPublicKey = deriveEncPubKey(expected_encKey) in
    {41}if (attester_enc_pk = expected_encPubKey) then
    {42}new seed: VFSeed;
    {43}let vf_1: ValidatorFactor = mkVF(seed,expected_ifa) in
    {44}event VFReleased(vf_1);
    {45}new nonce_1: Nonce;
    {46}event VerifierGeneratesNonce(nonce_1);
    {47}let plaintext_1: bitstring = (vf_1,nonce_1) in
    {48}let ciphertext_1: bitstring = penc(plaintext_1,attester_enc_pk) in
    {32}let verifierIdKey_1: IdentityKey = verifierIdKey in
    {49}let verifier_signature: Signature = sign(ciphertext_1,verifierIdKey_1) in
    {50}out(public_channel, (ciphertext_1,verifier_signature));
    {51}in(public_channel, (final_eat_payload_1: bitstring,final_signature_1: Signature,final_pubKey: PublicKey));
    {52}let verified_final: bitstring = verify(final_eat_payload_1,final_signature_1,final_pubKey) in
    {53}let (rec_ihb: IHB,rec_nonce: Nonce,rec_pubKey: PublicKey,rec_binding: BindingProof) = verified_final in
    {54}if (rec_nonce = nonce_1) then
    {55}let expected_idKey: IdentityKey = deriveIdKey(expected_bf,vf_1,uuid_1) in
    {56}let expected_pubKey: PublicKey = derivePubKey(expected_idKey) in
    {57}if (final_pubKey = expected_pubKey) then
    {58}if verifyBindingProof(rec_binding,expected_bf,vf_1,rec_ihb,rec_pubKey,rec_nonce) then
    {59}event VerifierValidatesBinding(expected_bf,vf_1,rec_ihb,rec_pubKey,rec_nonce);
    {60}event VerifierAccepts(expected_bf,expected_ifa,uuid_1);
    {61}event ProtocolCompleted(uuid_1)
) | (
    {62}let verifierIdKey_2: IdentityKey = verifierIdKey in
    {63}event VerifierKeyCompromised(verifierIdKey_2);
    {64}out(public_channel, verifierIdKey_2)
)

-- Query not attacker(bootFactor[]) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not attacker(bootFactor[])
goal reachable: attacker(bootFactor[])

Derivation:

1. The attacker initially knows bootFactor[].
attacker(bootFactor[]).

2. By 1, attacker(bootFactor[]).
The goal is reached, represented in the following fact:
attacker(bootFactor[]).


A more detailed output of the traces is available with
  set traceDisplay = long.

new instanceFactor: InstanceFactor creating instanceFactor_1 at {1}

new ecaUuid: UUID creating ecaUuid_1 at {2}

new verifierIdKey: IdentityKey creating verifierIdKey_3 at {3}

event VerifierKeyCompromised(verifierIdKey_3) at {63}

out(public_channel, ~M) with ~M = verifierIdKey_3 at {64}

event AttesterInitiates(bootFactor,instanceFactor_1,ecaUuid_1) at {12}

out(public_channel, ((~M_1,~M_2),~M_3)) with ~M_1 = deriveEncPubKey(deriveEncKey(bootFactor,instanceFactor_1,ecaUuid_1)), ~M_2 = calculateIHB(bootFactor,instanceFactor_1), ~M_3 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor,instanceFactor_1,ecaUuid_1)),calculateIHB(bootFactor,instanceFactor_1)),deriveAuthKey(bootFactor,instanceFactor_1,ecaUuid_1)) at {15}

The attacker has the message bootFactor.
A trace has been found.
RESULT not attacker(bootFactor[]) is false.
-- Query not attacker(deriveIdKey(bf_1,vf_2,uuid_2)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not attacker(deriveIdKey(bf_1,vf_2,uuid_2))
goal reachable: attacker(bf_1) && attacker(vf_2) && attacker(uuid_2) -> attacker(deriveIdKey(bf_1,vf_2,uuid_2))

Derivation:

1. We assume as hypothesis that
attacker(uuid_2).

2. We assume as hypothesis that
attacker(vf_2).

3. We assume as hypothesis that
attacker(bf_1).

4. By 3, the attacker may know bf_1.
By 2, the attacker may know vf_2.
By 1, the attacker may know uuid_2.
Using the function deriveIdKey the attacker may obtain deriveIdKey(bf_1,vf_2,uuid_2).
attacker(deriveIdKey(bf_1,vf_2,uuid_2)).

5. By 4, attacker(deriveIdKey(bf_1,vf_2,uuid_2)).
The goal is reached, represented in the following fact:
attacker(deriveIdKey(bf_1,vf_2,uuid_2)).


A more detailed output of the traces is available with
  set traceDisplay = long.

new instanceFactor: InstanceFactor creating instanceFactor_1 at {1}

new ecaUuid: UUID creating ecaUuid_1 at {2}

new verifierIdKey: IdentityKey creating verifierIdKey_3 at {3}

event VerifierKeyCompromised(verifierIdKey_3) at {63}

out(public_channel, ~M) with ~M = verifierIdKey_3 at {64}

event AttesterInitiates(bootFactor,instanceFactor_1,ecaUuid_1) at {12}

out(public_channel, ((~M_1,~M_2),~M_3)) with ~M_1 = deriveEncPubKey(deriveEncKey(bootFactor,instanceFactor_1,ecaUuid_1)), ~M_2 = calculateIHB(bootFactor,instanceFactor_1), ~M_3 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor,instanceFactor_1,ecaUuid_1)),calculateIHB(bootFactor,instanceFactor_1)),deriveAuthKey(bootFactor,instanceFactor_1,ecaUuid_1)) at {15}

The attacker has the message deriveIdKey(a,a_1,a_2).
A trace has been found.
RESULT not attacker(deriveIdKey(bf_1,vf_2,uuid_2)) is false.
-- Query inj-event(VerifierAccepts(bf_1,ifa_1,uuid_2)) ==> inj-event(AttesterInitiates(bf_1,ifa_1,uuid_2)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query inj-event(VerifierAccepts(bf_1,ifa_1,uuid_2)) ==> inj-event(AttesterInitiates(bf_1,ifa_1,uuid_2))
goal reachable: b-event(@p_act(@occ16[],(penc((mkVF(seed_1,instanceFactor[]),nonce_2),deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[]))),sign(penc((mkVF(seed_1,instanceFactor[]),nonce_2),deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[]))),verifierIdKey[])))) && b-inj-event(AttesterInitiates(bootFactor[],instanceFactor[],ecaUuid[]),@occ12[]) -> inj-event(VerifierAccepts(bootFactor[],instanceFactor[],ecaUuid[]),@occ60_1)
The 1st, 2nd hypotheses occur strictly before the conclusion.
Abbreviations:
seed_1 = seed[phase1_mac_1 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[])),deriveAuthKey(bootFactor[],instanceFactor[],ecaUuid[])),phase1_payload_1 = (deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[]))]
nonce_2 = nonce_1[phase1_mac_1 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[])),deriveAuthKey(bootFactor[],instanceFactor[],ecaUuid[])),phase1_payload_1 = (deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[]))]
@occ60_1 = @occ60[final_pubKey = derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_1,instanceFactor[]),ecaUuid[])),final_signature_1 = sign((calculateIHB(bootFactor[],instanceFactor[]),nonce_2,derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_1,instanceFactor[]),ecaUuid[])),computeBindingProof(bootFactor[],mkVF(seed_1,instanceFactor[]),calculateIHB(bootFactor[],instanceFactor[]),derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_1,instanceFactor[]),ecaUuid[])),nonce_2)),deriveIdKey(bootFactor[],mkVF(seed_1,instanceFactor[]),ecaUuid[])),final_eat_payload_1 = (calculateIHB(bootFactor[],instanceFactor[]),nonce_2,derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_1,instanceFactor[]),ecaUuid[])),computeBindingProof(bootFactor[],mkVF(seed_1,instanceFactor[]),calculateIHB(bootFactor[],instanceFactor[]),derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_1,instanceFactor[]),ecaUuid[])),nonce_2)),phase1_mac_1 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[])),deriveAuthKey(bootFactor[],instanceFactor[],ecaUuid[])),phase1_payload_1 = (deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[]))]
RESULT inj-event(VerifierAccepts(bf_1,ifa_1,uuid_2)) ==> inj-event(AttesterInitiates(bf_1,ifa_1,uuid_2)) is true.
-- Query event(AttesterUsesNonce(n)) ==> event(VerifierGeneratesNonce(n)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query event(AttesterUsesNonce(n)) ==> event(VerifierGeneratesNonce(n))
goal reachable: attacker(n) -> event(AttesterUsesNonce(n))

Derivation:

1. The message verifierIdKey[] may be sent to the attacker at output {64}.
attacker(verifierIdKey[]).

2. The message ((deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[])),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[])),deriveAuthKey(bootFactor[],instanceFactor[],ecaUuid[]))) may be sent to the attacker at output {15}.
attacker(((deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[])),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[])),deriveAuthKey(bootFactor[],instanceFactor[],ecaUuid[])))).

3. By 2, the attacker may know ((deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[])),computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[])),deriveAuthKey(bootFactor[],instanceFactor[],ecaUuid[]))).
Using the function 1-proj-2-tuple the attacker may obtain (deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[])).
attacker((deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[]))).

4. By 3, the attacker may know (deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[])).
Using the function 1-proj-2-tuple the attacker may obtain deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])).
attacker(deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[]))).

5. We assume as hypothesis that
attacker(n).

6. The attacker has some term vf_2.
attacker(vf_2).

7. By 6, the attacker may know vf_2.
By 5, the attacker may know n.
Using the function 2-tuple the attacker may obtain (vf_2,n).
attacker((vf_2,n)).

8. By 7, the attacker may know (vf_2,n).
By 4, the attacker may know deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])).
Using the function penc the attacker may obtain penc((vf_2,n),deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[]))).
attacker(penc((vf_2,n),deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])))).

9. By 8, the attacker may know penc((vf_2,n),deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[]))).
By 1, the attacker may know verifierIdKey[].
Using the function sign the attacker may obtain sign(penc((vf_2,n),deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[]))),verifierIdKey[]).
attacker(sign(penc((vf_2,n),deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[]))),verifierIdKey[])).

10. By 8, the attacker may know penc((vf_2,n),deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[]))).
By 9, the attacker may know sign(penc((vf_2,n),deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[]))),verifierIdKey[]).
Using the function 2-tuple the attacker may obtain (penc((vf_2,n),deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[]))),sign(penc((vf_2,n),deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[]))),verifierIdKey[])).
attacker((penc((vf_2,n),deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[]))),sign(penc((vf_2,n),deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[]))),verifierIdKey[]))).

11. The message (penc((vf_2,n),deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[]))),sign(penc((vf_2,n),deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[]))),verifierIdKey[])) that the attacker may have by 10 may be received at input {16}.
So event AttesterUsesNonce(n) may be executed at {20}.
event(AttesterUsesNonce(n)).

12. By 11, event(AttesterUsesNonce(n)).
The goal is reached, represented in the following fact:
event(AttesterUsesNonce(n)).


A more detailed output of the traces is available with
  set traceDisplay = long.

new instanceFactor: InstanceFactor creating instanceFactor_1 at {1}

new ecaUuid: UUID creating ecaUuid_1 at {2}

new verifierIdKey: IdentityKey creating verifierIdKey_3 at {3}

event VerifierKeyCompromised(verifierIdKey_3) at {63}

out(public_channel, ~M) with ~M = verifierIdKey_3 at {64}

event AttesterInitiates(bootFactor,instanceFactor_1,ecaUuid_1) at {12}

out(public_channel, ((~M_1,~M_2),~M_3)) with ~M_1 = deriveEncPubKey(deriveEncKey(bootFactor,instanceFactor_1,ecaUuid_1)), ~M_2 = calculateIHB(bootFactor,instanceFactor_1), ~M_3 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor,instanceFactor_1,ecaUuid_1)),calculateIHB(bootFactor,instanceFactor_1)),deriveAuthKey(bootFactor,instanceFactor_1,ecaUuid_1)) at {15}

in(public_channel, (penc((a,a_1),~M_1),sign(penc((a,a_1),~M_1),~M))) with penc((a,a_1),~M_1) = penc((a,a_1),deriveEncPubKey(deriveEncKey(bootFactor,instanceFactor_1,ecaUuid_1))), sign(penc((a,a_1),~M_1),~M) = sign(penc((a,a_1),deriveEncPubKey(deriveEncKey(bootFactor,instanceFactor_1,ecaUuid_1))),verifierIdKey_3) at {16}

event AttesterUsesNonce(a_1) at {20} (goal)

The event AttesterUsesNonce(a_1) is executed at {20}.
A trace has been found.
RESULT event(AttesterUsesNonce(n)) ==> event(VerifierGeneratesNonce(n)) is false.
-- Query event(VerifierValidatesBinding(bf_1,vf_2,ihb_1,pk,n)) ==> event(AttesterPresentsKey(pk)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query event(VerifierValidatesBinding(bf_1,vf_2,ihb_1,pk,n)) ==> event(AttesterPresentsKey(pk))
goal reachable: b-event(AttesterPresentsKey(derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_1,instanceFactor[]),ecaUuid[])))) -> event(VerifierValidatesBinding(bootFactor[],mkVF(seed_1,instanceFactor[]),calculateIHB(bootFactor[],instanceFactor[]),derivePubKey(deriveIdKey(bootFactor[],mkVF(seed_1,instanceFactor[]),ecaUuid[])),nonce_2))
Abbreviations:
seed_1 = seed[phase1_mac_1 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[])),deriveAuthKey(bootFactor[],instanceFactor[],ecaUuid[])),phase1_payload_1 = (deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[]))]
nonce_2 = nonce_1[phase1_mac_1 = computeMAC((deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[])),deriveAuthKey(bootFactor[],instanceFactor[],ecaUuid[])),phase1_payload_1 = (deriveEncPubKey(deriveEncKey(bootFactor[],instanceFactor[],ecaUuid[])),calculateIHB(bootFactor[],instanceFactor[]))]
RESULT event(VerifierValidatesBinding(bf_1,vf_2,ihb_1,pk,n)) ==> event(AttesterPresentsKey(pk)) is true.
-- Query not (event(VFReleased(vf_2)) && attacker(vf_2)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not (event(VFReleased(vf_2)) && attacker(vf_2))
RESULT not (event(VFReleased(vf_2)) && attacker(vf_2)) is true.

--------------------------------------------------------------
Verification summary:

Query not attacker(bootFactor[]) is false.

Query not attacker(deriveIdKey(bf_1,vf_2,uuid_2)) is false.

Query inj-event(VerifierAccepts(bf_1,ifa_1,uuid_2)) ==> inj-event(AttesterInitiates(bf_1,ifa_1,uuid_2)) is true.

Query event(AttesterUsesNonce(n)) ==> event(VerifierGeneratesNonce(n)) is false.

Query event(VerifierValidatesBinding(bf_1,vf_2,ihb_1,pk,n)) ==> event(AttesterPresentsKey(pk)) is true.

Query not (event(VFReleased(vf_2)) && attacker(vf_2)) is true.

--------------------------------------------------------------

