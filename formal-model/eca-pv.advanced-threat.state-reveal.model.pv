(* ECA Protocol - ProVerif Model v6 - ADVANCED THREATS
  State Reveal Test with Consolidated Binding Proof
  
  See the BASELINE model for normative tests
*)

(* --- Types --- *)
type BootFactor.
type InstanceFactor.
type VFSeed.
type ValidatorFactor.
type IdentityKey.
type PublicKey.
type EncPrivateKey.
type EncPublicKey.
type IHB.
type Signature.
type Nonce.
type MAC.
type BindingProof.
type UUID.

(* --- Constants and Channels --- *)
free public_channel: channel.
free bootFactor: BootFactor. (* BF is public, as intended *)

(* --- Cryptographic Primitives --- *)

(* Key Derivations with UUID for session uniqueness *)
fun deriveIdKey(BootFactor, ValidatorFactor, UUID): IdentityKey.
fun derivePubKey(IdentityKey): PublicKey.
fun deriveEncKey(BootFactor, InstanceFactor, UUID): EncPrivateKey [private].
fun deriveEncPubKey(EncPrivateKey): EncPublicKey.

(* MAC for initial proof *)
fun deriveAuthKey(BootFactor, InstanceFactor, UUID): bitstring.
fun computeMAC(bitstring, bitstring): MAC.
reduc forall m: bitstring, k: bitstring; verifyMAC(m, computeMAC(m, k), k) = true.

(* Protocol-specific calculations *)
fun calculateIHB(BootFactor, InstanceFactor): IHB.

(* CONSOLIDATED: Single binding proof replaces JP + PoP *)
fun computeBindingProof(BootFactor, ValidatorFactor, IHB, PublicKey, Nonce): BindingProof.
reduc forall bf: BootFactor, vf: ValidatorFactor, ihb: IHB, pk: PublicKey, n: Nonce;
      verifyBindingProof(computeBindingProof(bf, vf, ihb, pk, n), bf, vf, ihb, pk, n) = true.

(* Standard Signatures *)
fun sign(bitstring, IdentityKey): Signature.
reduc forall m: bitstring, ik: IdentityKey; verify(m, sign(m, ik), derivePubKey(ik)) = m.

(* HPKE-style Encryption *)
fun penc(bitstring, EncPublicKey): bitstring.
reduc forall m: bitstring, ek: EncPrivateKey; pdec(penc(m, deriveEncPubKey(ek)), ek) = m.

fun mkVF(VFSeed, InstanceFactor): ValidatorFactor [private].

(* --- Events --- *)
event AttesterInitiates(BootFactor, InstanceFactor, UUID).
event VerifierAccepts(BootFactor, InstanceFactor, UUID).
event VFReleased(ValidatorFactor).
event VerifierGeneratesNonce(Nonce).
event AttesterUsesNonce(Nonce).
event AttesterPresentsKey(PublicKey).
event VerifierValidatesBinding(BootFactor, ValidatorFactor, IHB, PublicKey, Nonce).
event ProtocolCompleted(UUID).
event VerifierKeyCompromised(IdentityKey).
event EphemeralKeyCompromised(EncPrivateKey, UUID).

(* --- Sanity Check: BF should be public, so this should be true --- *)
query attacker(bootFactor).

(* --- Sanity Check: The function to derive keys should be known --- *)
query bf: BootFactor, vf: ValidatorFactor, uuid: UUID;
      attacker(deriveIdKey(bf, vf, uuid)).
      
(* --- Core Security Queries --- *)
query bf: BootFactor, ifa: InstanceFactor, uuid: UUID;
      inj-event(VerifierAccepts(bf, ifa, uuid)) ==> inj-event(AttesterInitiates(bf, ifa, uuid)).
query n: Nonce;
      event(AttesterUsesNonce(n)) ==> event(VerifierGeneratesNonce(n)).
query pk: PublicKey, bf: BootFactor, vf: ValidatorFactor, ihb: IHB, n: Nonce;
      event(VerifierValidatesBinding(bf, vf, ihb, pk, n)) ==> event(AttesterPresentsKey(pk)).
query vf: ValidatorFactor;
      event(VFReleased(vf)) && attacker(vf).

(* --- Protocol Participants --- *)

let AttesterProcess(bf: BootFactor, ifa: InstanceFactor, uuid: UUID, verifierPubKey: PublicKey) =
    (* Phase 1: Prove possession of bf using the instance factor *)
    let authKey = deriveAuthKey(bf, ifa, uuid) in
    let encKey = deriveEncKey(bf, ifa, uuid) in
    let encPubKey = deriveEncPubKey(encKey) in
    let ihb = calculateIHB(bf, ifa) in
    event AttesterInitiates(bf, ifa, uuid);
    let phase1_payload = (encPubKey, ihb) in
    let phase1_mac = computeMAC(phase1_payload, authKey) in
    out(public_channel, (phase1_payload, phase1_mac));

    (* Phase 2: Receive the encrypted (VF, nonce) tuple *)
    in(public_channel, (ciphertext: bitstring, verifier_sig: Signature));
    let verified_ciphertext = verify(ciphertext, verifier_sig, verifierPubKey) in
    let plaintext = pdec(verified_ciphertext, encKey) in
    let (vf: ValidatorFactor, nonce: Nonce) = plaintext in
    event AttesterUsesNonce(nonce);

    (* Phase 3: Final proof using CONSOLIDATED binding *)
    let idKey = deriveIdKey(bf, vf, uuid) in
    let pubKey = derivePubKey(idKey) in
    event AttesterPresentsKey(pubKey);
    let binding_proof = computeBindingProof(bf, vf, ihb, pubKey, nonce) in
    let final_eat_payload = (ihb, nonce, pubKey, binding_proof) in
    let final_signature = sign(final_eat_payload, idKey) in
    out(public_channel, (final_eat_payload, final_signature, pubKey));
    
    event ProtocolCompleted(uuid).

let VerifierProcess(expected_bf: BootFactor, expected_ifa: InstanceFactor, 
                    uuid: UUID, verifierIdKey: IdentityKey) =
    (* Phase 1: Verify Attester's proof of possession *)
    in(public_channel, (phase1_payload: bitstring, phase1_mac: MAC));
    let (attester_enc_pk: EncPublicKey, received_ihb: IHB) = phase1_payload in
    let expected_authKey = deriveAuthKey(expected_bf, expected_ifa, uuid) in

    if verifyMAC(phase1_payload, phase1_mac, expected_authKey) then
        let expected_ihb = calculateIHB(expected_bf, expected_ifa) in
        if received_ihb = expected_ihb then
            let expected_encKey = deriveEncKey(expected_bf, expected_ifa, uuid) in
            let expected_encPubKey = deriveEncPubKey(expected_encKey) in
            if attester_enc_pk = expected_encPubKey then
                (* Phase 2: Create and encrypt (VF, nonce) tuple *)
                new seed: VFSeed;
                let vf = mkVF(seed, expected_ifa) in
                event VFReleased(vf);
                new nonce: Nonce;
                event VerifierGeneratesNonce(nonce);
                let plaintext = (vf, nonce) in
                let ciphertext = penc(plaintext, attester_enc_pk) in
                let verifier_signature = sign(ciphertext, verifierIdKey) in
                out(public_channel, (ciphertext, verifier_signature));

                (* Phase 3: Verify CONSOLIDATED binding proof *)
                in(public_channel, (final_eat_payload: bitstring, final_signature: Signature, final_pubKey: PublicKey));
                let verified_final = verify(final_eat_payload, final_signature, final_pubKey) in
                let (rec_ihb: IHB, rec_nonce: Nonce, rec_pubKey: PublicKey, rec_binding: BindingProof) = verified_final in
                if rec_nonce = nonce then
                    let expected_idKey = deriveIdKey(expected_bf, vf, uuid) in
                    let expected_pubKey = derivePubKey(expected_idKey) in
                    if final_pubKey = expected_pubKey then
                        if verifyBindingProof(rec_binding, expected_bf, vf, rec_ihb, rec_pubKey, rec_nonce) then
                            event VerifierValidatesBinding(expected_bf, vf, rec_ihb, rec_pubKey, rec_nonce);
                            event VerifierAccepts(expected_bf, expected_ifa, uuid);
                            event ProtocolCompleted(uuid); 0
                        else 0
                    else 0
                else 0
            else 0
        else 0
    else 0.

(* --- Additional Processes for Security Testing --- *)

(* Process that leaks the verifier's long-term key *)
let LeakVerifierKey(verifierIdKey: IdentityKey) =
    event VerifierKeyCompromised(verifierIdKey);
    out(public_channel, verifierIdKey).

(* Process that leaks an ephemeral encryption key *)
let LeakEphemeralKey(bf: BootFactor, ifa: InstanceFactor, uuid: UUID) =
    let encKey = deriveEncKey(bf, ifa, uuid) in
    event EphemeralKeyCompromised(encKey, uuid);
    out(public_channel, encKey).

(* --- Main Process --- *)
process
    (* Standard protocol run *)
    new instanceFactor: InstanceFactor;
    new ecaUuid: UUID;
    new verifierIdKey: IdentityKey;
    let verifierPubKey = derivePubKey(verifierIdKey) in
    
    (* Run the protocol *)
    (
        AttesterProcess(bootFactor, instanceFactor, ecaUuid, verifierPubKey)
        |
        VerifierProcess(bootFactor, instanceFactor, ecaUuid, verifierIdKey)
        |
        LeakEphemeralKey(bootFactor, instanceFactor, ecaUuid) (* State Reveal Test *)
        (* Expected: Released VF will fall into the command of an attacker *)
    )

(* 
Expected Results and How to Test:

1. Forward Secrecy Test:
   (
        AttesterProcess(bootFactor, instanceFactor, ecaUuid, verifierPubKey)
        |
        VerifierProcess(bootFactor, instanceFactor, ecaUuid, verifierIdKey)
        |
        LeakVerifierKey(verifierIdKey)  (* ADD/CHANGE THIS LINE *)
   )
   Expected: VF should remain secret even with verifier key leaked
   Expected: nonce Freshness guarantee fails
   
2. State Reveal Test:
   (
        AttesterProcess(bootFactor, instanceFactor, ecaUuid, verifierPubKey)
        |
        VerifierProcess(bootFactor, instanceFactor, ecaUuid, verifierIdKey)
        |
        LeakEphemeralKey(bootFactor, instanceFactor, ecaUuid)  (* ADD/CHANGE THIS LINE *)
   )
   Expected: Released VF will fall into the command of an attacker

---

All Expected Results:

Query not attacker(bootFactor[]) is false.
Query not attacker(deriveIdKey(bf_2,vf_2,uuid_3)) is false.

Query inj-event(VerifierAccepts(bf_2,ifa_2,uuid_3)) ==> inj-event(AttesterInitiates(bf_2,ifa_2,uuid_3)) is true.
Query event(AttesterUsesNonce(n)) ==> event(VerifierGeneratesNonce(n)) is true.
Query event(VerifierValidatesBinding(bf_2,vf_2,ihb_1,pk,n)) ==> event(AttesterPresentsKey(pk)) is true.

Query not (event(VFReleased(vf_2)) && attacker(vf_2)) is false.

---

Changes in v6
- Tests unifying JP + PoP into single binding proof 

Changes in v5
- BASELINE test is now "unbounded" (see seperate model)

Changes in v4
- Version number skipped

Changes in v3 - BASELINE:
- Updated to include Key Compromise Impersonation (KCI) test
  - Tests whether compromising an Instance Factor allows impersonating the Verifier

Changes in v3 - ADVANCED THREATS:
- Added queries for forward secrecy and state reveal resistance
- New events for tracking key compromises
- Simplified test processes for ProVerif compatibility
- Documentation of security properties and expected results

Changes in v2:
- Added UUID type and ecaUuid parameter throughout
- All key derivation functions now include UUID for session uniqueness
- Phase 2 now encrypts the tuple (VF, nonce) as specified, not just VF
- Events updated to include UUID for tracking per-ceremony uniqueness


Author's Address:  
  Nathanael Ritz
  Independent
  nathanritz@gmail.com
*)
